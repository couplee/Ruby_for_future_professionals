文字列の値が同じか違うか調べる方法
"Lui" == "Lui"         # true
"Lui" == "lui"          # false
"Luna" != "Luna"        # false
"Luna" != "luna"          # true

大小関係を比較。この場合、文字コードが大小比較の基準になる。
"a" < "b"         # true
"a" < "A"     # false
"a" > "A"     # true
"abc" < "def"      # true
"abc" < "ab"     # false
"abc" < "abcd"    # true
"あいうえお" < "かきくけこ"   # true



10  # 正の整数
1.5  # 小数
-3  # 負の整数
-4.75  # 負の小数

1_000_000_000  # 数値は_を含めることができて、_は無視されるから、大きな数の区切り文字として使うと便利(左は1000000000という意味)


n = 1
-n    # -1になる

1 / 2  # 「0」整数同士の割り算は小数点以下は切り捨てられて整数になる

1.0 / 2  # 小数点以下の数値がいる場合、どちらかの値に小数点の.0をつける
1 / 2.0

n = 1  # 変数に整数が入っていて、整数から少数に変更する方法
n.to_f  # 1.0に変更
n.to_f / 2  # 0.5になる


Rubyには変数の値を増減させる++や--のような演算子がないため、+=や-=、*=、/=、**=を使う
n = 1
n += 1   # n = n + 1と同じ
n -= 1  # n = n - 1と同じ
n *= 3  # nを3倍にする
n /= 2  # nを2で割る
n **= 2  # nを2乗する


数値と文字列は暗黙的に変換されない
1 + '10'  # エラー
1 + '10'.to_i  # 11になる
1 + '10.5'.to_f  # 11.5になる

number = 3
'Number is ' + number  # エラー
'Number is ' + number.to_s  # Number is 3になる

"Number is #{number}"  # 式展開#{}を使ったら自動的にto_sメソッドが呼ばれるから、文字列に変換する必要はない



小数を使う時は丸め誤差に注意
0.1 * 3.0  # 0.3にならず、0.30000000000000004になる。だから下2行もfalseになってしまう
0.1 * 3.0 == 0.3  # false
0.1 * 3.0 <= 0.3  # false
上記のコードはRationalクラスを使うと期待通りの結果が得られる
0.1r * 3.0r  # 3/10になる。だから下2行もtrueになる
0.1r * 3r == 0.3  # true
0.1r * 3r <= 0.3  # true
変数に値が入ってる場合は.rationalizeを記述
a = 0.1
b = 3.0
a.rationalize * b.rationalize  # 3/10になる。a * bだと0.30000000000000004になる
rationalizeから普通に小数に戻す場合は、計算結果に対してto_fメソッドを呼ぶ
(0.1r * 3.0r).to_f  # 0.3になる。0.1r * 3.0rだと3/10になる


                # 🔵 2.5.2 論理演算子
条件1 && 条件2
t1 = true
t2 = true
f1 = false
t1 && t2  # true
t1 && f1  # false

条件1 || 条件2
t1 = true
f1 = false
f2 = false
t1 || f1  # true
f1 || f2  # false

&&と||を組み合わせる
条件1 && 条件2 || 条件3 && 条件4  # 条件1かつ条件2が真、または条件3かつ条件4が真なら真
&&の優先順位が||より高いから、上記の式は下記の意味になる
(条件1 && 条件2) || (条件3 && 条件4)
ex)
t1 = true
t2 = true
f1 = false
f2 = false
t1 && t2 || f1 && f2  #=> true
上記と下記は同じ意味
(t1 && t2) || (f1 && f2)

優先順位を変えたい場合は()を使う
条件1 && (条件2 || 条件3) && 条件4  # 条件1が真かつ、条件2または条件3が真かつ、条件4が真なら真
ex)
t1 = true
t2 = true
f1 = false
f2 = false
t1 && (t2 || f1) && f2  #=> false(条件4が真じゃないから)

!演算子を使うと真偽値が反転する
t1 = true
f1 = false
!t1  #=> false
!f1  #=> true

!()にすると、()の中の真偽値が反転する
t1 = true
f1 = false
t1 && f1  #=> false
!(t1 && f1)  #=> true

