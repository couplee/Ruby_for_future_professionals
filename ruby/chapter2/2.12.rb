             💠 2.12 その他の基礎知識

             💠 2.12.1 ガベージコレクション(GC)の意味はP.59確認
             
             💠 2.12.2 エイリアスメソッド
  Rubyにはまったく同じメソッドに複数の名前が付いてることがよくある。たとえば、Stringクラスのlengthメソッドとsizeメソッドは、名前が違うだけでどっちもまったく同じメソッド
    ex) lengthとsizeは、どっちも文字数を返す
'hello'.length  #=> 5
'hello'.size  #=> 5

  上記のようにまったく同じ実装で名前だけ異なるメソッドのことをエイリアスメソッドと呼ぶ。
  lengthとsizeみたいに、同じメソッドに複数の名前が用意されてる場合、開発者の好みでしっくりくるほうを選んでいい。
  エイアリスメソッドも自分で定義することができる(P.263で説明する)



             💠 2.12.3 式と文
  Rubyでは「値を返して、結果を変数に代入できるものが式」、「値を返さず、変数に代入しようとすると構文エラーになるものが文」と定義してる。
  だからRubyのif文やメソッド定義は値を返すから、文ではなく式になってる。
    ex) if文が値を返すから変数に代入できる
a = 
  if true
    '真です'
  else
    '偽です'
  end
a  #=> '真です'

  ex) メソッドの定義も実は値(シンボル)を返してる(シンボルは第5章確認)
b = def foo; end
b  #=> :foo

  だから厳密に言うと、Rubyのif文は「if式」、メソッド定義の構文は「メソッド定義式」と呼んだ方が適してるが、
  「if式」も「メソッド定義式」も、式のように扱われるとは限らない（戻り値が無視されるケースも多い）から、
  Rubyでは「文のように見えるけど実は式」という要素が多い(=やろうと思えば戻り値を活用できる)ことを知っておく



                    💠 2.12.4 擬似変数
  この章で登場したnil、true、falseは擬似変数と呼ばれる特殊な変数。Rubyには他にも擬似変数がある（下記参照）
  ・self：オブジェクト自身(第7章参照)
  ・__FILE__：現在のソースファイル名
  ・__LINE__：現在のソースファイル中の行番号
  ・__ENCODING__：現在のソースファイルのスクリプトエンコーディング
  
  擬似変数は文法上、変数のように見えるが、代入しようとするとエラーが発生する
true = 1  #=> SyntaxError



                     💠 2.12.5 参照の概念を理解する
  ex) aとbはどちらも同じ文字列だけど、オブジェクトとしては別物
a = 'hello'
b = 'hello'
a.object_id  #=> 22611560
b.object_id  #=> 22636320

  ex) cにbを代入すると、bとcはどちらも同じオブジェクト
c = b
c.object_id  #=> 22636320

  ex) メソッドの引数にcを渡すと、引数として受け取ったdはbとcと同じオブジェクト
def m(d)
  d.object_id
end
m(c)  #=> 22636320

  ex) equal?メソッドを使って同じオブジェクトかどうかを確認することもできる(trueなら同じオブジェクト)
a.equal?(b)  #=> false
b.equal?(c)  #=> true


  同じオブジェクトを参照してる場合、オブジェクトの状態が変更されると、その変更あそのまま各変数に影響する
    ex) bとcは同じオブジェクト、aは違うオブジェクト
a = 'hello'
b = 'hello'
c = b

def m!(d)  # 渡された文字列を破壊的に大文字に変換するメソッドを定義する
  d.upcase!
end

m!(c)  # cにm!メソッドを適用する

b  #=> "HELLO"  # b、cは同じオブジェクトのため、どちらも大文字になる
c  #=> "HELLO"

a  #=> "hello"  # aは別のオブジェクトだから大文字にならない

  bとcどちらも大文字に変わった理由は、メソッドm!の中で変更した引数のdがb、cと同じオブジェクトを参照していたから。
  同一のオブジェクトを参照してるのか、異なるオブジェクトを参照してるのか意識しないと、思いがけないバグを作り込んでしまうことがある。



                💠 2.12.6 組み込みライブラリ、標準ライブラリ、gem
                
                💠 2.12.7 require
  組み込みライブラリではない、標準ライブラリやgemを利用する場合、下記の構文のように明示的にそのライブラリを読み込む必要がある
require ライブラリ名

    ex) Dateクラスを使いたい場合、dateライブラリを読み込む
Date.today  #=> NameError  # Dateクラスは読み込みライブラリではないから、そのままでは使用できない

require 'date'  # dateライブラリを読み込むと、Dateクラスが使えるようになる
Date.today  #=> <Date: 2021-05-04 ((2459339j,0s,0n),+0s,2299161j)>


  また、自分で作成したRubyプログラム（クラスと定義など）うぃ読み込む場合もrequireを使う。
  この場合、Rubyを実行してるディレクトリからの相対パス、または絶対パスで指定する。
    ex) 同じディレクトリに自分で作成したsample.rbというファイルがあって、それを読み込みたい場合
require './sample.rb'  # 拡張子の.rbは省略可能だが、いずれも./(現在のディレクトリ)や/(ルートディレクトリ)を使って、相対パスや絶対パスの形式で書き始める必要がある



                   💠 2.12.8 load
  requireは1回しかライブラリやrbファイルを読み込まない点に注意。
  requireを使った時にfalseが返ってきた場合、すでに読み込み済みであることを示してる。
    ex) irb上で下記のような操作をしても、sample.rbの変更を反映されない
require './sample.rb'  #=> true  # 自分で書いたプログラムを読み込む

# その後、不具合があったから、sample.rbを修正する

require './sample.rb'  #=> false  # もう一度requireしてもすでに読み込み済みだから修正が反映されない

  こういう時はrequireではなく、loadを使うと、毎回無条件に指定したファイルを読み込むことができる
load '.sample.rb'  #=> true

load './sample.rb'  #=> true  # loadを使うと無条件に再読み込みできるからファイルの変更が反映されるが、loadを使う場合、拡張子の.rbは省略できない



                      💠 2.12.9 require_relative
  requireはRubyを実行してるディレクトリがパスの起点になるが、require_relativeを使うと、自分のファイルが存在するディレクトリがパスの起点になる
    ex) foo/hello.rbからbar.bye.rbを読み込みたい場合、require_relativeを使う時(../は1つ上のディレクトリを表す)
require_relative '../bar/bye'  # foo/hello.rbから見た相対パスでbar/bye.rbを読み込む

    Rubyの実行ディレクトリの影響を受けずにプログラムを読み込みたい場合、require_relativeの利用を検討するといい



                          💠 2.12.10 putsメソッド、printメソッド、pメソッド
  putsメソッド、printメソッド、pメソッドはターミナル（正確には標準出力）への出力でよく使われる。
  この3つのメソッドはよく似てるが、微妙に挙動が異なる。
    ex) putsメソッドは改行を加えて、変数の内容やメソッドの戻り値をターミナルに出力する。またputsメソッド自身の戻り値はnilになる
puts 123
#=> 123  # 2行に改行されてる
#=> => nil

puts 'abc'
#=> abc  # 2行に改行されてる
#=> => nil


    ex) printメソッドは改行を加えない（=> nilが改行されずに表示されている点に注目する）
print 123
#=> 123 => nil

print 'abc'
#=> abc => nil


    ex) pメソッドはputsメソッドと同じように改行を加えて表示するが、文字列を出力すると、その文字列がダブルクォーテーションに囲まれてる点がputsメソッドと異なる。
        またpメソッドは引数で渡されたオブジェクトそのものがメソッドの戻り値になる。（=> のあとに続いてる値にも注目する）
p 123
#=> 123
#=> => 123

p 'abc'
#=> "abc"
#=> => "abc"


    ex) 今度は改行文字(\n)を含む文字列をそれぞれのメソッドに渡してみる
s = "abc\ndef"
#=> => "abc\ndef"

puts s
#=> abc
#=> def
#=> => nil

print s
#=> abc
#=> def => nil

p s
#=> "abc\ndef"
#=> => "abc\ndef"

  putsメソッドやprintメソッドでは、文字列が"abc"と"def"の間で改行されて出力されるが、pメソッドでは改行文字(\n)が改行文字のまま出力される。
  配列(第4章で説明するからここでは結果だけを確認する)を渡した時の表示も異なる
a = [1, 2, 3]
#=> => [1, 2, 3]

puts a
#=> 1
#=> 2
#=> 3
#=> => nil

print a
#=> [1, 2, 3] => nil

p a
#=> [1, 2, 3]
#=> => [1, 2, 3]

  このように、putsメソッドだけ各要素が改行された。この3つのメソッドの使い分けの仕方は
  putsメソッドとprintメソッドは一般ユーザ向け、pメソッドは開発者向け。(理由はP.66、67確認)