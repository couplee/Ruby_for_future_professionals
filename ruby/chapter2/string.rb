# classメソッドでクラス名を確認 ※irbで実行
"abc".class  #=> String


            # 💠 2.8.2 %記法で文字列を作る
# %qの場合、!はシングルクォーテーションで囲むのと同じ
puts %q!He said, "Don't speak."!  #=> He said, "Don't speak."

# %Qの場合、!はダブルクォーテーションで囲むのと同じ ※改行文字や式展開が使える(下の式が式展開を使ってる)
something = "Hello."
puts %Q!He said, "#{something}"!  #=> He said, "Hello."

# %!の場合、!はダブルクォーテーションで囲むのと同じ ※改行文字や式展開が使える(下の式が式展開を使ってる)
something = "Bye."
puts %!He said, "#{something}"!  #=> He said, "Bye."

# !を?や^など、任意の記号を区切り文字として使える(下の式は?を使用)
puts %q?He said, "Don't speak."?  #=> He said, "Don't speak."

# <や{や(や[を区切り文字として使う場合、終わりの区切り文字と同じカッコウが区切り文字になる(下の式は{}を区切り文字にしてる)
puts %q{He said, "Don't speak."}  #=> He said, "Don't speak."


                  # 💠 2.8.3 ヒアドキュメント(行指向文字列リテラル)＝文字列を途中で改行
puts "Line 1,
Line 2"
#=> Line 1,
#   Line 2

# 複数行の長い文字列の場合、ヒアドキュメント(行指向文字列リテラル)を使う方がスッキリする
# ヒアドキュメント(行指向文字列リテラル)の書き方
# <<識別子
# 文字
# 文字
# 文字
# 識別子

# ex) ※下の式は文字列をaに代入してる
a = <<TEXT
これはヒアドキュメントです。
複数行に渡る長い文字列を作成するのに便利です。
TEXT
puts a
#=> これはヒアドキュメントです。
#   複数行に渡る長い文字列を作成するのに便利です。

# 上の式で利用した識別子(TEXT)などは自由につけられるが、記述する文字列の中に含まれない文字列を使う
# ex) HTMLを識別子として使う
<<HTML
<div>
  <img src="sample.jpg">
</div>
HTML

# <<-TEXTのように-を入れると、最後の識別子をインデントさせることができる。今回は<<-TEXTとTEXTの前にインデントを入れてる※-がないとエラーになる
def some_method
  <<-TEXT
これはヒアドキュメントです。
<<-を使うと最後の識別子をインデントさせることができます。
  TEXT
end
puts some_method
#=> これはヒアドキュメントです。
#   <<-を使うと最後の識別子をインデントさせることができます。

# Ruby 2.3以降では<<~TEXTのように~を使うことができる。~を使うと文字列をインデントしても、実行するとインデントが無視されて先頭の空白が表示されない。今回は69行目と70行目のインデントがなくなってる
def some_method
  <<~TEXT
    これはヒアドキュメントです。
    <<~を使うと内部文字列のインデント部分が無視されます。
  TEXT
end
puts some_method
#=> これはヒアドキュメントです。
#   <<~を使うと内部文字列のインデント部分が無視されます。

# ヒアドキュメントの中では式展開ができる
name = "Alice"
a = <<TEXT
ようこそ、#{name}さん！
以下のメッセージをご覧ください。
TEXT
puts a
#=> ようこそ、Aliceさん！
#   以下のメッセージをご覧ください。

# <<'TEXT'のように、識別子をシングルクォーテーションで囲むと式展開ができない
name = "Alice"
a = <<'TEXT'
ようこそ、#{name}さん！
以下のメッセージをご覧ください。
TEXT
puts a
#=> ようこそ、#{name}さん！
#   以下のメッセージをご覧ください。

# <<"TEXT"のように、識別子をダブルクォーテーションで囲むと式展開ができる＝<<TEXTと書くのと同じ意味
name = "Alice"
a = <<"TEXT"
ようこそ、#{name}さん！
以下のメッセージをご覧ください。
TEXT
puts a
#=> ようこそ、Aliceさん！
#   以下のメッセージをご覧ください。

# 開始ラベルの<<識別子は一つの式とみなされるから、<<識別子をメソッドの引数として渡したり、<<識別子に対してメソッドを呼び出したりすることができる
# ex) ヒアドキュメントを直接引数として渡す
a = 'Ruby'
a.prepend(<<TEXT)  # .prependは渡された文字列(今回はJavaとPHP)を先頭に追加するメソッド
Java
PHP
TEXT
puts a
#=> Java
#   PHP
#   Ruby

# ヒアドキュメントで作成した文字列に対して、直接upcaseメソッドを呼び出す
b = <<TEXT.upcase  # .upcaseは文字列を全て大文字にするメソッド
Hello,
Good-bye.
TEXT
puts b
#=> HELLO,
#   GOOD-BYE.



              # 💠 2.8.4 フォーマットを指定して文字列を作成する
# sprintfメソッドを使用すると、指定されたフォーマットの文字列を作成することができる
# ex) 以下は小数第3位まで数字を表示する文字列を作成するコード例
sprintf('%0.3f', 1.2)  #=> "1.200"

# 少し変わった構文になるが、以下のように"フォーマット文字列 % 表示したいオブジェクト"の形式で書いても上の式と同じ結果になる
'%0.3f' % 1.2  #=> "1.200"

# 表示したいオブジェクトを複数渡すこともできる
sprintf('%0.3f + %0.3f', 1.2, 0.48)  #=> "1.200 + 0.480"
sprintf('%0.7f + %0.5f', 1.2, 0.48)  #=> "1.2000000 + 0.48000"
'%0.3f + %0.3f' % [1.2, 0.48]  #=>"1.200 + 0.480"
'%0.4f + %0.6f' % [1.2, 0.48]  #=>"1.2000 + 0.480000"


                          # 💠 2.8.5 その他、文字列作成のいろいろ
# ほかのオブジェクトから文字列を作ることができ、以下は無数にあるバリエーションの一例
123.to_s  #=> "123"  # 数字を文字列に変換する
[10, 20, 30].join  #=> "102030"  # 配列を連結して一つの文字列にする
'Hi!' * 10  #=> "Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!"  # *演算子を使って文字列を繰り返す
String.new('hello')  #=> "hello"  # String.newを使って新しい文字列を作る(あまり使わん)
"\u3042\u3044\u3046"  #=> "あいう"  # ダブルクォーテーションと\uを組み合わせてUnicodeのコードポイントから文字列を作成することもできる


                            # 💠 2.8.6 文字と文字列の違いはない
# 他のプログラミング言語では1文字だけの「文字」と、複数文字の「文字列」を別々に扱うものもあるが、Rubyでは違いはなく、いずれも「文字列(Stringオブジェクト)」として扱われる
'a'  #=> "a"  # 1文字でも文字列
'abc'  #=> "abc"  # 2文字以上でも文字列
'' #=> ""  # 0文字でも文字列
?a  #=> "a"  # あまり使われないが、?を使って1文字だけの文字列を作ることもできる


               # 💠 2.9.4
# 数値関連のクラスにはいくつかの種類がある。例えば整数ならIntegerクラス、小数であればFLoatクラスになる
10.class  #=> Integer
1.5.class  #=> Float

# Ruby2.3までの整数は、とても大きい数の場合Bignumクラス、それ以外はFixnumクラスに分かれてたが、Ruby2.4からは整数は全部Integerクラスにまとめられた
# ex) Ruby2.3まではBignumクラスとFixnumクラスがあった
10.class  #=> Fixnum
9999999999999999999.class  #=> Bignum
# ex) Ruby2.4以降はどちらもIntegerクラスになった
10.class  #=> Integer
9999999999999999999.class  #=> Integer


# 他にも有理数を表すRationalクラスや、複素数を表すComplexクラスがある
# 有理数リテラル(3rが有理数リテラル)
r = 2 / 3r
r  #=> (2/3)
r.class  #=> Rational

# 文字列から有理数に変換
r = '2/3'.to_r
r  #=> (2/3)
r.class  #=> Rational

# 複素数リテラル(0.5iが複素数リテラル)
c = 0.3 - 0.5i
c  #=> (0.3-0.5i)
c.class  #=> Complex

# 文字列から複素数に変換
c = '0.3-0.5i'.to_c
c  #=> (0.3-0.5i)
c.class  #=> Complex

# ※️ここで説明した数値クラスはすべてNumeric(数値)クラスのサブクラス。各クラスの継承関係はP.49の図2-1参照