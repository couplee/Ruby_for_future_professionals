                          💠 4.5 範囲(Range)
  Rubyには「1から5まで」や「文字'a'から'e'まで」みたいに、値の範囲を表すオブジェクトがある。これを範囲オブジェクトと言う。範囲オブジェクトの構文は
  最初の値..最後の値(最後の値を含む)
  最初の値...最後の値(最後の値を含まない)
  
    ex)
1..5
1...5
'a'..'e'
'a'...'e'

  範囲オブジェクトはrangeクラスのオブジェクト
(1..5).class  #=> Range
(1...5).class  #=> Range

  ..と...の違いは、最後の値を範囲に含めるか含めないかの違いになる。include?メソッドを使うと引数の値に含まれるかどうかを判定できるから、このメソッドを使って..と...の違いを確認する
range = 1..5  # ..を使ったら、最後の値5が範囲に含まれる
range.include?(0)  #=> false
range.include?(1)  #=> true
range.include?(4.9)  #=> true
range.include?(5)  #=> true
range.include?(6)  #=> false

range = 1...5  # ...を使ったら、最後の値5が範囲に含まれない(4.9999....までが含まれる)
range.include?(0)  #=> false
range.include?(1)  #=> true
range.include?(4.9)  #=> true
range.include?(5)  #=> false
range.include?(6)  #=> false

  ⚠️なお、範囲オブジェクトを変数に入れずに、直接include?のようなメソッドを呼び出す時は範囲オブジェクトを()で囲む必要がある
1..5.include?(1)  #=> NoMethodErrorというエラーになる
(1..5).include?(1)  #=> true # エラーにならない

  これは..や...の優先順位が低いから。()で囲んでないほうのコードは下記のように解釈されたから、エラーが発生した
1..5.include?(1))



                  💠 4.5.1 配列や文字列の一部を抜き出す
  配列に対して添え字の代わりに範囲オブジェクトを渡すと、指定した範囲の要素を取得できる
a = [1, 2, 3, 4, 5]
a[1..3]  #=> [2, 3, 4]  # 2番目から4番目までの要素を取得する

  文字列に対しても同じような操作ができる
a = 'abcdef'
a[1..3]  #=> "bcd"  # 2番目から4番目を抜き出す



            💠 4.5.2 n以上m以下、n以上m未満の判定をする
  n以上m以下、n以上m未満の判定をしたい場合、<や>=のような記号(不等号)を使うよりも範囲オブジェクトを使った方がシンプルに書ける
    ex) 不等号を使う場合
def liquid?(temperature)
  0 <= temperature && temperature < 100
end
liquid?(-1)  #=> false
liquid?(0)  #=> true
liquid?(99)  #=> true
liquid?(100)  #=> false

    ex) 範囲オブジェクトを使う場合
def liquid?(temperature)
  (0...100).include?(temperature)
end
liquid?(-1)  #=> false
liquid?(0)  #=> true
liquid?(99)  #=> true
liquid?(100)  #=> false



                  💠 4.5.3 case文を使う
  範囲オブジェクトはcase文と組み合わせることができる。
    ex) 年齢に応じて料金を判定するメソッド
def charge(age)
  case age
  when 0..5  #=> 0歳から5歳までの場合
    0
  when 6..12  #=> 6歳から12歳までの場合
    300
  when 13..18  #=> 13歳から18歳までの場合
    600
  else  #=> それ以外の場合
    1000
  end
end
charge(3)  #=> 0
charge(12)  #=> 300
charge(16)  #=> 600
charge(25)  #=> 1000


            💠 4.5.4 値が連続する配列を作成する
  範囲オブジェクトに対してto_aオブジェクトを呼び出すと、値が連続する配列を作成できる
(1..5).to_a  #=> [1, 2, 3, 4, 5]
(1...5).to_a  #=> [1, 2, 3, 4]

('a'..'e').to_a  #=> ["a", "b", "c", "d", "e"]
('a'...'e').to_a  #=> ["a", "b", "c", "d"]

('bad'..'bag').to_a  #=> ["bad", "bae", "baf", "bag"]
('bad'...'bag').to_a  #=> ["bad", "bae", "baf"]

  []の中に*と範囲オブジェクトを書いても同じように配列を作れる(*を使って複数の値を配列に展開することをsplat展開と言う)
[*1..5]  #=> [1, 2, 3, 4, 5]
[*1...5]  #=> [1, 2, 3, 4]



              💠 4.5.5 繰り返し処理を行う
  範囲オブジェクトを配列に変換すれば、配列として繰り返し処理を行える
numbers = (1..4).to_a  # 範囲オブジェクトを配列に変換してから繰り返し処理を行う
sum = 0
numbers.each { |n| sum += n }
sum  #=> 10

  だが、配列に変換しなくても、範囲オブジェクトに対して直接eachメソッドを呼び出すことも可能
sum = 0
(1..4).each { |n| sum += n }
sum  #=> 10

  stepメソッドを呼び出すと、値を増やす間隔を指定できる
numbers = []
(1..10).step(2) { |n| numbers << n }
numbers  #=> [1, 3, 5, 7, 9]



                💠 4.6 例題：RGB変換プログラムを作成する
  RGB変換プログラムの仕様をもう1回確認
    ・to_hexメソッド→10進数を16進数に変換する。3つの整数を受け取って、それぞれを16進数に変換した文字列を返す。文字列の先頭には"#"をつける
    ・to_intsメソッド→16進数を10進数に変換する。RGBカラーを表す16進数文字列を受け取って、R,G,Bのそれぞれを10進数の整数に変換した値を配列として返す
    
      ex)
    to_hex(0, 0, 0)  #=> '#000000'
    to_hex(255, 255, 255)  #=> '#ffffff'
    to_hex(4, 60, 120)  #=> '#043c78'
    to_ints('#000000')  #=> [0, 0, 0]
    to_ints('#ffffff')  #=> [255, 255, 255]
    to_ints('#043c78')  #=> [4, 60, 120]



                    💠 4.6.1 to_hexメソッドを作成する
  rgb_test.rbファイルとrgb.rbファイルへ
  rgb.rbファイルに記述したコードの意味は整数値を16進数の文字列に変換する必要があるから、to_sメソッドを使うといい。下記のコードをirbで試すとわかりやすい
0.to_s(16)  #=> "0"
255.to_s(16)  #=> "ff"

  上記のように、to_sメソッドで整数を16進数に変換できる。だが、0のときは2桁の文字列"00"になるはずが、1桁の"0"になってる。
  この場合はrjustメソッドを使って右寄せするといい。構文.rjust(◯, '◆')は、第一引数の◯には桁数を指定する。第二引数の◆には空白以外の文字列を指定して埋めることができる（デフォルトは半角スペースの空白で桁揃えされる）
    ex)
'0'.rjust(5)  #=> "    0"  # 桁数を指定する第一引数を5にしてるから、5桁表示される
'0'.rjust(5, '0')  #=> "00000"  # 今度は空白表示される前の4桁を文字列で表示されるよう、第二引数に文字列(今回は0)を指定してる
'0'.rjust(5, '_')  #=> "____0"  # 今度は空白表示される前の4桁を文字列で表示されるよう、第二引数に文字列(今回は_)を指定してる

  このメソッドを使えば、0を2桁の"00"に変換できる
0.to_s(16).rjust(2, '0')  #=> "00"
255.to_s(16).rjust(2, '0')  #=> "ff"

  これでrgb.rbファイルに記述したコードの意味がわかる



                  💠 4.6.2  to_hexメソッドをリファクタリングする
  リファクタリングとは外から見た振る舞いは保ったまま、理解や修正が簡単になるように内部のコードを改善すること。4.6.1で作成したrgb.rbファイルに記述したto_hexメソッドをもう一度確認すると、
def to_hex(r, g, b)
'#' +
  r.to_s(16).rjust(2, '0') +
  g.to_s(16).rjust(2, '0') +
  b.to_s(16).rjust(2, '0')
end
  のように、.to_s(16).rjust(2, '0')を3回記述してる。これだと今後何か変更があったときに同じ変更を3回繰り返す必要があるから、to_hexメソッドからコードの重複を取り除こう。
  同じ処理を3回繰り返す場合、r,g,bの各値を配列に入れて繰り返し処理すればいいから、下記のコードに記述を変更する
def to_hex(r, g, b)
  hex = '#'
  [r, g, b].each do |n|
    hex += n.to_s(16).rjust(2, '0')
  end
  hex
end

  上のコードでは、[r, g, b]のように、引数として渡された各値を配列に入れたあと、eachメソッドを使って繰り返し処理をしてる。eachメソッドの内部では数値を16進数に変換した文字列を、ブロックの外で作成したhex変数に連結してる。
  そして最後に変数hexをメソッドの戻り値として返却してる。これで.to_s(16).rjust(2, '0')は1回しか記述する必要がなくなった。これでも得られる結果は同じだからテストもパスする。
  だが、これだけで終わりでなく、この章で習ったRubyの便利メソッドを使えばもっとコードを短くシンプルにできる。ここではinjectメソッドを使ってto_hexメソッドをリファクタリングして、下記のように短くシンプルにコードが書ける。
def to_hex(r, g, b)
  [r, g, b].inject('#') do |hex, n|
    hex + n.to_s(16).rjust(2, '0')
  end
end

  上記のコードのポイントは3つある
    ・最初の繰り返し処理ではhexに'#'が入る
    ・ブロックの中のhex + n.to_s(16).rjust(2, '0')で作成された文字列は、次の繰り返し処理のhexに入る
    ・繰り返し処理が最後まで到達したら、ブロックの戻り値がinjectメソッド自身の戻り値になる
  これでリファクタリングは完成して、to_hexメソッドも完成した。



                  💠 4.6.3 to_intsメソッドを作成する
  to_intsメソッドは16進数の文字列を10進数の数値3つに変換するメソッド
to_ints('#000000')  #=> [0, 0, 0]
to_ints('#ffffff')  #=> [255, 255, 255]
to_ints('#043c78')  #=> [4, 60, 120]

  まず、to_hexメソッドのときと同じようにテストコードを書く
def test_to_ints
  assert_equal [0, 0, 0], to_ints('#000000')
end
  この状態だと、to_intsメソッドはまだ作成してないから、テストは失敗する。だから、rgb.rbファイルにto_intsメソッドの仮実装を追記する
def to_ints(hex)
  [0, 0, 0]
end

  今度はrgb_test.rbファイルに下記のコードを追記すると、またエラーになる
assert_equal [255, 255, 255], to_ints('#ffffff')

  to_intsメソッドの実装で必要な手順は大きく分けて2つある
    ・文字列から16進数の文字列を2文字ずつ取り出す
    ・2桁の16進数を10進数の整数に変換する
    
  まず、16進数の文字列を2文字ずつ取り出す方法は、[]と範囲オブジェクトを使う。たとえば、文字列の2文字目から4文字目までを取り出したい場合、下記のようにして取り出す
s = 'abcde'
s[1..3]  #=> "bcd"
  この方法を利用して、文字列からR,G,Bの各値を取り出すことができる。
hex = '#12abcd'
r = hex[1..2]  #=> "12"
g = hex[3..4]  #=> "ab"
b = hex[5..6]  #=> "cd"

  次は16進数の文字列を10進数の整数に変換する方法。これはStringクラスにhexというメソッドがある。
'00'.hex  #=> 0
'ff'.hex  #=> 255
'2a'.hex  #=> 42

  これらの知識を総合すると、to_intsメソッドを下記のように実装できる
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6]
  ints = []
  [r, g, b].each do |s|
    ints << s.hex
  end
  ints
end

  上のコードの処理フローは下記の通り
    ・引数の文字列から3つの16進数を引き出す
    ・3つの16進数を配列に入れ、ループを回しながら10進数の整数に変換した値を別の配列に詰め込む
    ・10進数の整数が入った配列を返す
    
  これでテストはパスした。念のために、r, g, bの各値がバラバラになるケースもテストしてみる
assert_equal [4, 60, 120], to_ints('#043c78')

  これもテストがパスした。だが、to_intsメソッドもリファクタリングできる部分があるから次の章でする



                    💠 4.6.4 to_intsメソッドをリファクタリングする
  上記で実装したto_intsメソッドをもう一度見てみる
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6]
  ints = []
  [r, g, b].each do |s|
    ints << s.hex
  end
  ints
end
  繰り返し処理はmapメソッドが最も適してるロジックである。
  「4.4.1 map/collect」でも学習したが、mapメソッドとは「空の配列を用意して、ほかの配列をループ処理した結果を空の配列に詰め込んでいくような処理の大半は、mapメソッドに置き換えることができるはず」
  だから、実装したto_intsメソッドをmapメソッドに置き換えると
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6]
  [r, g, b].map do |s|
    s.hex
  end
end
  mapメソッドはブロックの戻り値を配列の要素にして新しい配列を返すメソッドだから、わざわざintsのような変数を用意しなくても、mapメソッドとブロックだけで処理できる。これでパスもする



                  💠 4.6.5 to_intsメソッドをリファクタリングする(上級編)
  Rubyに慣れると、もっとコードを短くすることができる。
  まず最初にr,g,bという変数を作って代入してるが、ここは改行しないで多重代入を使って1行にしても、可読性は悪くならない
def to_ints(hex)
  r, g, b = hex[1..2], hex[3..4], hex[5..6]
  [r, g, b].map do |s|
    s.hex
  end
end

  さらに、範囲オブジェクトの代わりに正規表現（第6章で学習する）とscanメソッドを使うと、一気に文字列を3つの16進数に分割できる
def to_ints(hex)
  r, g, b = hex.scan(/\w\w/)
  [r, g, b].map do |s|
    s.hex
  end
end

  scanメソッドは正規表現にマッチした文字列を配列にして返す（r, g, bに対して多重代入できるのもscanメソッドが配列を返してるから）
'#12abcd'.scan(/\w\w/)  #=> ["12", "ab", "cd"]

  だから、一度変数に入れて[r, g, b]みたいな配列を作らんでも、scanメソッドの戻り値に対して直接mapメソッドを呼べる
def to_ints(hex)
  hex.scan(/\w\w/).map do |s|
    s.hex
  end
end

  また、「4.4.5 &とシンボルと使ってもっと簡潔に書く」で学習したように、下記の条件が揃ったときに、ブロックの代わりに&:メソッド名という引数を渡すことができる
    ・ブロック引数が1個だけある
    ・ブロックの中で呼び出すメソッドには引数がない
    ・ブロックの中では、ブロック引数に対してメソッドを1回呼び出す以外の処理がない
  to_intsメソッドの中で書いてる武録の処理がこれに該当するから、ブロックをなくして、代わりに&:hexをmapメソッドの引数に渡す
def to_ints(hex)
  hex.scan(/\w\w/).map(&:hex)
end

  これで1行で実装できた。テストもパスする。リファクタリング前と後のコードを比べてみる
  リファクタリング前
def to_ints(hex)
  r = hex[1..2]
  g = hex[3..4]
  b = hex[5..6]
  ints = []
  [r, g, b].each do |s|
    ints << s.hex
  end
  ints
end

  リファクタリング後
def to_ints(hex)
  hex.scan(/\w\w/).map(&:hex)
end

  どこかリファクタリングできる部分がないか研究することを心がけるとRubyのプログラミングスキルが向上する。
  ここまで学習したテスト駆動開発の開発サイクルはP.114を見て、もう一度復習する。