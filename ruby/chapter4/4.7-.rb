                    💠 4.7 配列についてもっと詳しく
                    💠 4.7.1 さまざまな要素の取得方法
  添え字を二つ使ったら、添字の位置と取得する長さを指定できる。この場合、配列が返ってくる。下記は構文
配列[位置, 取得する長さ]

  ex) 二つ目の要素から3つ分の要素を取り出すコード
a = [1, 2, 3, 4, 5]
a[1, 3]  #=> [2, 3, 4]

  🌟ex) 4つ目の要素から2つ分の要素を取り出すコード
b = [8, 9, 10, 11, 12, 13, 14, 15]
b[3, 2]  #=> [11, 12]


  values_atメソッドを使ったら、取得したい要素の添え字を複数指定できる
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4)  #=> 1, 3, 5

🌟
b = [8, 9, 10, 11, 12, 13]
b.values_at(1, 3, 5)  #=> 9, 11, 13  # 配列の一番目、三番目、五番目の要素の添え字を指定した


  「配列の長さ - 1」を指定すると、最後の要素を取得できる
a = [1, 2, 3]
a[a.size - 1]  #=> 3

🌟
b = [5, 6, 7, 8]
b[b.size - 1]  #=> 8


  だが、Rubyでは添え字に負の値が使える。-1は最後の要素、-2は最後から2番目の要素、のように指定できる
a = [1, 2, 3]
a[-1]  #=> 3  # 最後の要素を取得
a[-2]  #=> 2  # 最後から2番目の要素を取得
a[-2, 2]  #=> [2, 3]  # 最後から2番目の要素から2つの要素を取得。配列で返ってきてる

🌟
b = [5, 6, 7, 8]
b[-1]  #=> 8
b[-3]  #=> 6
b[-2, 2]  #=> [7, 8]


  さらに、配列にはlastというメソッドがあり、これを呼ぶと配列の最後の要素を取得できる。引数に0以上の数値を渡すと、渡した数値の分だけの最後のn個の要素を取得できる
a = [1, 2, 3]
a.last  #=> 3
a.last(2)  #=> [2, 3]  # 最後の2個の要素を取得

🌟
b = [5, 6, 7, 8]
b.last  #=>  8
b.last(3)  #=> [6, 7, 8]


  lastの反対のfirstもあって、政党の要素を取得するメソッド
a = [1, 2, 3]
a.first  #=> 1
a.first(2)  #=> [1, 2]

🌟
b = [5, 6, 7, 8]
b.first  #=> 5
b.first(3)  #=> [5, 6, 7]



                              💠 4.7.2 さまざまな要素の変更方法
  値を変更する場合も負の添字が使えるが、正の値を使う時と違って、元の大きさを超えるような添え字を指定したらエラーになる
a = [1, 2, 3]
a[-3]  = -10  # 最後から3つ目の要素を-10に書き換える
a  #=> [-10, 2, 3]
a[-4] = 0  #=> IndexError (index -4 too small for array; minimum: -3)  # 指定可能な負の値よりも小さくなるとエラーになる

🌟
b = [5, 6, 7, 8]
b[-2] = -70
b  #=> [5, 6, -70, 8]
b[-4] = -5
b  #=> [-5, 6, -70, 8]
b[-5] = -4  #=> IndexError (index -5 too small for array; minimum: -4)  # 元は4つしか要素がないから、最後から5つ目の要素を指定したらエラーになった


  開始位置と長さを指定して、要素を置き換えることもできる
a = [1, 2, 3, 4, 5]
a[1, 3] = 100  # 2つ目から3要素分を100で置き換える
a  #=> [1, 100, 5]

🌟
b = [5, 6, 7, 8, 9, 10]
b[3, 3] = 300  # 4つ目から要素分を300に置き換える
b  #=> [5, 6, 7, 300]


  <<だけでなく、pushメソッドを使っても要素を追加できる。pushメソッドの場合、複数の値を追加できる
a = []
a.push(1)  #=> [1]
a.push(2, 3)  #=> [1, 2, 3]

🌟
b = []
b.push(5)  #=> [5]
b.push(7, 9)  #=> [5, 7, 9]


  指定した値に一致する要素を削除したい場合、deleteメソッドを使う
a = [1, 2, 3, 1, 2, 3]
a.delete(2)  #=> 2  # 値が2である要素を削除する（削除した値が戻り値になる）
a  #=> [1, 3, 1, 3]

a.delete(5)  #=> nil  # 存在しない値を指定するとnilが返ってくる
a  #=> [1, 3, 1, 3]

🌟
b = [5, 6, 7, 8, 5, 6, 7, 8]
b.delete(7)  #=> 7
b  #=> [5, 6, 8, 5, 6, 8]

b.delete(3)  #=> nil
b  #=> [5, 6, 8, 5, 6, 8]



                    💠 4.7.3 配列の連結
  2つの配列を連結したい場合、concatメソッドか+演算子を使う。違いは元の配列を変更するかどうか（破壊的かどうか）という点。concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更される
a = [1]
b = [2, 3]
a.concat(b)  #=> [1, 2, 3]

a  #=> [1, 2, 3]  # aは変更される（破壊的に）
b  #=> [2, 3]  # bは変更されない


🌟
c = [5, 6]
d = [7, 8, 9]
c.concat(d)  #=> [5, 6, 7, 8, 9]

c  #=> [5, 6, 7, 8, 9]
d  #=> [7, 8, 9]


  一方で、+を使ったら元の配列を変更せずに、新しい配列を作成する
a = [1]
b = [2, 3]
a + b  #=> [1, 2, 3]

a  #=> [1]  # 変更されない(非破壊的)
b  #=> [2, 3]  # 変更されない（非破壊的）

  どっちも「配列を連結する」という使い方は同じだけど、破壊的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合があるから、どうしてもという場合以外は+演算子を使う方がいい



                    💠 4.7.4 配列の和集合、差集合、積集合
  Rubyの配列は|、-、&を使って、和集合、差集合、積集合を求めることができる。|は和集合を求める演算子。2つの配列の要素をすべて集めて、重複しないように返す
a = [1, 2, 3]
b = [3, 4, 5]
a | b  #=> [1, 2, 3, 4, 5]

🌟
c = [5, 6, 7, 8]
d = [7, 8, 9, 10, 5]
c | d  #=> [5, 6, 7, 8, 9, 10]  # dの最後の5も重複してる点に注意


  -は差集合を求める演算子。左の配列から右の配列に含まれる演算子を取り除く
a = [1, 2, 3]
b = [3, 4, 5]
a - b  #=> [1, 2]  # aの3を取り除いた

🌟
c = [5, 6, 7, 8, 9]
d = [6, 8, 9, 10]
c - d  #=> [5, 7]  # cの6,8,9を取り除いた


  &は積集合を求める演算子。2つの配列に共通する要素を返す
a = [1, 2, 3]
b = [3, 4, 5]
a & b  #=> [3]  # 2つの配列に共通する要素は3だから

🌟
c = [5, 6, 7, 8, 9]
d = [1, 3, 5, 7, 9, 11]
c & d  #=> [5, 7, 9]


  |、-、&のどれも、元の配列は変更しない(非破壊的)
  なお、Rubyには配列よりも"効率的に"集合を扱えるSetクラスもある。本格的な集合演算をする場合、配列よりもSetクラスを使う方がいい
require 'set'

a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
a | b  #=> #<Set: {1, 2, 3, 4, 5}>
a - b  #=> #<Set: {1, 2}>
a & b  #=> #<Set: {3}>



                    💠 4.7.5 多重代入で残りの全要素を配列として受け取る
  多重代入では左辺の変数よりも右辺の個数が多い場合、はみ出した値が切り捨てられると学習した（「2.2.8 変数(ローカル変数)の宣言と代入）」、「4.2.2 配列を使った多重代入」）
e, f = 100, 200, 300
e  #=> 100
f  #=> 200

  だが、左辺の変数に*をつけたら、残りの全要素を配列として受け取ることができる
e, *f = 100, 200, 300
e  #=> 100
f  #=> [200, 300]

🌟
g, *h = 500, 600, 700, 800
g  #=> 500
h  #=> [600, 700, 800]



                  💠 4.7.6 1つの配列を複数の引数として展開する
  pushメソッドはa.push(2, 3)みたいにして、複数の要素を一度に追加できると学習した
a = []
a.push(1)  #=> [1]
a.push(2, 3)  #=> [1, 2, 3]

  もしこの2,3が配列になっていた場合はどうなるか？下記を参照しよう
a = []
b = [2, 3]
a.push(1)  #=> [1]
a.push(b)  #=> [1, [2, 3]]  # 配列がそのまま追加される(a.push([2, 3])と同じ)

  このように、2つの要素じゃなく。1つの配列として要素が追加されてしまう。メソッドの引数に配列を渡す時、「1つの配列」じゃなく、配列を展開して「複数の引数」として渡したい場合、配列の前に*を置く(splat展開)
a = []
b = [2, 3]
a.push(1)  #=> [1]
a.push(*b)  #=> [1, 2, 3]  # 配列を*付きで追加する(a.push(2, 3)と同じ)

  イメージ的には下記のような動作になってる
a.push(*b)
↓
a.push(*[2, 3])
↓
a.push(2, 3)

  配列を引数に渡す場合、「1つの配列」として渡したいのか、「複数の引数」として渡したいのかを検討して、後者の場合は*を使って配列を展開できることを覚えておく



                      💠 4.7.7 メソッドの可変長引数
  さっき学習した配列のpushメソッドみたいに、個数に制限がない引数のことを可変長引数と言う。自分で定義するメソッドで可変長引数を使いたい場合、引数名の手前に*をつける
    構文)
  def メソッド名(引数1, 引数2, *可変長引数)
    # メソッドの処理
  end
  
  可変長引数は配列として受け取ることができる。たとえば、下記は引数として渡された人名の全員に挨拶をするメソッド。(コードで使われてるjoinメソッドは引数の区切り文字を使って配列を1つの文字列にするメソッド)
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
greeting('田中さん')  #=> "田中さん、こんにちは！"
greeting('田中さん', '鈴木さん')  #=> "田中さんと鈴木さん、こんにちは！"
greeting('田中さん', '鈴木さん', '佐藤さん')  #=> "田中さんと鈴木さんと佐藤さん、こんにちは！"


