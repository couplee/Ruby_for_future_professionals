                    💠 4.7 配列についてもっと詳しく
                    💠 4.7.1 さまざまな要素の取得方法
  添え字を二つ使ったら、添字の位置と取得する長さを指定できる。この場合、配列が返ってくる。下記は構文
配列[位置, 取得する長さ]

  ex) 二つ目の要素から3つ分の要素を取り出すコード
a = [1, 2, 3, 4, 5]
a[1, 3]  #=> [2, 3, 4]

  🌟ex) 4つ目の要素から2つ分の要素を取り出すコード
b = [8, 9, 10, 11, 12, 13, 14, 15]
b[3, 2]  #=> [11, 12]


  values_atメソッドを使ったら、取得したい要素の添え字を複数指定できる
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4)  #=> 1, 3, 5

🌟
b = [8, 9, 10, 11, 12, 13]
b.values_at(1, 3, 5)  #=> 9, 11, 13  # 配列の一番目、三番目、五番目の要素の添え字を指定した


  「配列の長さ - 1」を指定すると、最後の要素を取得できる
a = [1, 2, 3]
a[a.size - 1]  #=> 3

🌟
b = [5, 6, 7, 8]
b[b.size - 1]  #=> 8


  だが、Rubyでは添え字に負の値が使える。-1は最後の要素、-2は最後から2番目の要素、のように指定できる
a = [1, 2, 3]
a[-1]  #=> 3  # 最後の要素を取得
a[-2]  #=> 2  # 最後から2番目の要素を取得
a[-2, 2]  #=> [2, 3]  # 最後から2番目の要素から2つの要素を取得。配列で返ってきてる

🌟
b = [5, 6, 7, 8]
b[-1]  #=> 8
b[-3]  #=> 6
b[-2, 2]  #=> [7, 8]


  さらに、配列にはlastというメソッドがあり、これを呼ぶと配列の最後の要素を取得できる。引数に0以上の数値を渡すと、渡した数値の分だけの最後のn個の要素を取得できる
a = [1, 2, 3]
a.last  #=> 3
a.last(2)  #=> [2, 3]  # 最後の2個の要素を取得

🌟
b = [5, 6, 7, 8]
b.last  #=>  8
b.last(3)  #=> [6, 7, 8]


  lastの反対のfirstもあって、政党の要素を取得するメソッド
a = [1, 2, 3]
a.first  #=> 1
a.first(2)  #=> [1, 2]

🌟
b = [5, 6, 7, 8]
b.first  #=> 5
b.first(3)  #=> [5, 6, 7]



                              💠 4.7.2 さまざまな要素の変更方法
  値を変更する場合も負の添字が使えるが、正の値を使う時と違って、元の大きさを超えるような添え字を指定したらエラーになる
a = [1, 2, 3]
a[-3]  = -10  # 最後から3つ目の要素を-10に書き換える
a  #=> [-10, 2, 3]
a[-4] = 0  #=> IndexError (index -4 too small for array; minimum: -3)  # 指定可能な負の値よりも小さくなるとエラーになる

🌟
b = [5, 6, 7, 8]
b[-2] = -70
b  #=> [5, 6, -70, 8]
b[-4] = -5
b  #=> [-5, 6, -70, 8]
b[-5] = -4  #=> IndexError (index -5 too small for array; minimum: -4)  # 元は4つしか要素がないから、最後から5つ目の要素を指定したらエラーになった


  開始位置と長さを指定して、要素を置き換えることもできる
a = [1, 2, 3, 4, 5]
a[1, 3] = 100  # 2つ目から3要素分を100で置き換える
a  #=> [1, 100, 5]

🌟
b = [5, 6, 7, 8, 9, 10]
b[3, 3] = 300  # 4つ目から要素分を300に置き換える
b  #=> [5, 6, 7, 300]


  <<だけでなく、pushメソッドを使っても要素を追加できる。pushメソッドの場合、複数の値を追加できる
a = []
a.push(1)  #=> [1]
a.push(2, 3)  #=> [1, 2, 3]

🌟
b = []
b.push(5)  #=> [5]
b.push(7, 9)  #=> [5, 7, 9]


  指定した値に一致する要素を削除したい場合、deleteメソッドを使う
a = [1, 2, 3, 1, 2, 3]
a.delete(2)  #=> 2  # 値が2である要素を削除する（削除した値が戻り値になる）
a  #=> [1, 3, 1, 3]

a.delete(5)  #=> nil  # 存在しない値を指定するとnilが返ってくる
a  #=> [1, 3, 1, 3]

🌟
b = [5, 6, 7, 8, 5, 6, 7, 8]
b.delete(7)  #=> 7
b  #=> [5, 6, 8, 5, 6, 8]

b.delete(3)  #=> nil
b  #=> [5, 6, 8, 5, 6, 8]



                    💠 4.7.3 配列の連結
  2つの配列を連結したい場合、concatメソッドか+演算子を使う。違いは元の配列を変更するかどうか（破壊的かどうか）という点。concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更される
a = [1]
b = [2, 3]
a.concat(b)  #=> [1, 2, 3]

a  #=> [1, 2, 3]  # aは変更される（破壊的に）
b  #=> [2, 3]  # bは変更されない


🌟
c = [5, 6]
d = [7, 8, 9]
c.concat(d)  #=> [5, 6, 7, 8, 9]

c  #=> [5, 6, 7, 8, 9]
d  #=> [7, 8, 9]


  一方で、+を使ったら元の配列を変更せずに、新しい配列を作成する
a = [1]
b = [2, 3]
a + b  #=> [1, 2, 3]

a  #=> [1]  # 変更されない(非破壊的)
b  #=> [2, 3]  # 変更されない（非破壊的）

  どっちも「配列を連結する」という使い方は同じだけど、破壊的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合があるから、どうしてもという場合以外は+演算子を使う方がいい



                    💠 4.7.4 配列の和集合、差集合、積集合
  Rubyの配列は|、-、&を使って、和集合、差集合、積集合を求めることができる。|は和集合を求める演算子。2つの配列の要素をすべて集めて、重複しないように返す
a = [1, 2, 3]
b = [3, 4, 5]
a | b  #=> [1, 2, 3, 4, 5]

🌟
c = [5, 6, 7, 8]
d = [7, 8, 9, 10, 5]
c | d  #=> [5, 6, 7, 8, 9, 10]  # dの最後の5も重複してる点に注意


  -は差集合を求める演算子。左の配列から右の配列に含まれる演算子を取り除く
a = [1, 2, 3]
b = [3, 4, 5]
a - b  #=> [1, 2]  # aの3を取り除いた

🌟
c = [5, 6, 7, 8, 9]
d = [6, 8, 9, 10]
c - d  #=> [5, 7]  # cの6,8,9を取り除いた


  &は積集合を求める演算子。2つの配列に共通する要素を返す
a = [1, 2, 3]
b = [3, 4, 5]
a & b  #=> [3]  # 2つの配列に共通する要素は3だから

🌟
c = [5, 6, 7, 8, 9]
d = [1, 3, 5, 7, 9, 11]
c & d  #=> [5, 7, 9]


  |、-、&のどれも、元の配列は変更しない(非破壊的)
  なお、Rubyには配列よりも"効率的に"集合を扱えるSetクラスもある。本格的な集合演算をする場合、配列よりもSetクラスを使う方がいい
require 'set'

a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
a | b  #=> #<Set: {1, 2, 3, 4, 5}>
a - b  #=> #<Set: {1, 2}>
a & b  #=> #<Set: {3}>



                    💠 4.7.5 多重代入で残りの全要素を配列として受け取る
  多重代入では左辺の変数よりも右辺の個数が多い場合、はみ出した値が切り捨てられると学習した（「2.2.8 変数(ローカル変数)の宣言と代入）」、「4.2.2 配列を使った多重代入」）
e, f = 100, 200, 300
e  #=> 100
f  #=> 200

  だが、左辺の変数に*をつけたら、残りの全要素を配列として受け取ることができる
e, *f = 100, 200, 300
e  #=> 100
f  #=> [200, 300]

🌟
g, *h = 500, 600, 700, 800
g  #=> 500
h  #=> [600, 700, 800]



                  💠 4.7.6 1つの配列を複数の引数として展開する
  pushメソッドはa.push(2, 3)みたいにして、複数の要素を一度に追加できると学習した
a = []
a.push(1)  #=> [1]
a.push(2, 3)  #=> [1, 2, 3]

  もしこの2,3が配列になっていた場合はどうなるか？下記を参照しよう
a = []
b = [2, 3]
a.push(1)  #=> [1]
a.push(b)  #=> [1, [2, 3]]  # 配列がそのまま追加される(a.push([2, 3])と同じ)

  このように、2つの要素じゃなく。1つの配列として要素が追加されてしまう。メソッドの引数に配列を渡す時、「1つの配列」じゃなく、配列を展開して「複数の引数」として渡したい場合、配列の前に*を置く(splat展開)
a = []
b = [2, 3]
a.push(1)  #=> [1]
a.push(*b)  #=> [1, 2, 3]  # 配列を*付きで追加する(a.push(2, 3)と同じ)

  イメージ的には下記のような動作になってる
a.push(*b)
↓
a.push(*[2, 3])
↓
a.push(2, 3)

  配列を引数に渡す場合、「1つの配列」として渡したいのか、「複数の引数」として渡したいのかを検討して、後者の場合は*を使って配列を展開できることを覚えておく



                      💠 4.7.7 メソッドの可変長引数
  さっき学習した配列のpushメソッドみたいに、個数に制限がない引数のことを可変長引数と言う。自分で定義するメソッドで可変長引数を使いたい場合、引数名の手前に*をつける
    構文)
  def メソッド名(引数1, 引数2, *可変長引数)
    # メソッドの処理
  end
  
  可変長引数は配列として受け取ることができる。たとえば、下記は引数として渡された人名の全員に挨拶をするメソッド。(コードで使われてるjoinメソッドは引数の区切り文字を使って配列を1つの文字列にするメソッド)
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
greeting('田中さん')  #=> "田中さん、こんにちは！"
greeting('田中さん', '鈴木さん')  #=> "田中さんと鈴木さん、こんにちは！"
greeting('田中さん', '鈴木さん', '佐藤さん')  #=> "田中さんと鈴木さんと佐藤さん、こんにちは！"



              💠 4.7.8 *で配列同士を非破壊的に連結する
  []の中に*付きで別の配列を置くと、その配列が展開されて別々の要素になる。これもsplat展開の一種
a = [1, 2, 3]

[a]  #=> [[1, 2, 3]]  # []の中にそのまま配列を置いたら、配列の配列になる

[*a]  #=> [1, 2, 3]  # *付きで配列を置いたら、展開されて別々の要素になる

  これを利用したら、別の配列を要素の一部とする新しい配列を作れる
a = [1, 2, 3]
[-1, 0, *a, 4, 5]  #=> [-1, 0, 1, 2, 3, 4, 5]

  *じゃなく、下記のように+を使うことができるが、*を使った方が簡潔なコードになる
a = [1, 2, 3]
[-1, 0] + a + [4, 5]  #=> [-1, 0, 1, 2, 3, 4, 5]



                  💠 4.7.9 ==で等しい配列かどうか判断する
  ==と使ったら、左辺と右辺の配列が等しいかどうかをチェックできる。この場合、配列の前要素を==で比較して、すべて等しい場合は「2つの配列は等しい」と判断される
[1, 2, 3] == [1, 2, 3]  #=> true  # 配列が等しい場合

[1, 2, 3] == [1, 2, 4]  #=> false  # 配列が等しくない場合
[1, 2, 3] == [1, 2]  #=> false  # 配列が等しくない場合
[1, 2, 3] == [1, 2, 3, 4]  #=> false  # 配列が等しくない場合



                        💠 4.7.10 %記法で文字列の配列を簡潔に作る
  配列は[]を使って作成することが多いが、文字列については%記法の%wまたは%Wを使って作成する方法が用意されてる。%記法を使ったら、カンマじゃなく、空白文字(スペースや改行)が要素の区切り文字となる。
  また、文字列をシングルクオートやダブルクオートで囲む必要もないから、結果として[]を使う場合よりもコードが短くなる
    ex) []で文字列の配列を作成する
['apple', 'melon', 'orange']  #=> ["apple", "melon", "orange"]

    ex) %wで文字列の配列を作成する(!で囲む場合)
%w!apple melon orange!  #=> ["apple","melon", "orange"]

    ex) %wで文字列の配列を作成する(丸カッコで囲む場合)
%w(apple melon orange)  #=> ["apple","melon", "orange"]

    ex) 空白文字(スペースや改行)が連続した場合も一つの区切り文字とみなされる
%w(
  apple
  melon
  orange
)
#=> ["apple", "melon", "orange"]

  値にスペースを含めたい場合、バックスプラッシュでエスケープする
%w(big\ apple small\ melon orange)  #=> ["big apple", "small melon", "orange"]

  式展開や改行文字(\n)、タブ文字(\t)などを含めたい場合、%W(大文字のW)を使う
prefix = 'This is'
%W(#{prefix}\ an\ apple small\nmelon orange)  #=> ["This is an apple", "small\nmelon", "orange"]

  %記法は「2.8.2 %記法で文字列を作る」でも学習してるから、そっちも参照する。また、%記法でシンボルの配列を作る方法もある。これは「5.7.2 %記法でシンボルやシンボルの配列で作成する」で学習する



                        💠 4.7.11 文字列を配列に変換する
  文字列を分解して配列に変換することもできる。何個か方法はあるが、ここではcharsメソッドとsplitメソッドを学習する
  charsメソッドは文字列中の1文字1文字を配列の要素に分解するメソッド
'Ruby'.chars  #=> ["R", "u", "b", "y"]

  splitメソッドは引数で渡した区切り文字で文字列を配列に分割するメソッド
'Ruby,Java,Perl,PHP'.split(',')  #=> ["Ruby", "Java", "Perl", "PHP"]

  このほかにも正規表現と組み合わせて文字列を配列に変換できる。これについては「6.3.4 正規表現と組み合わせると便利なStringクラスのメソッド」で学習する



                              💠 4.7.12 配列に初期値を設定する
  ここまで配列の作成は[]を使ってきたが、このほかにもArray.newを使って作成する方法がある
a = Array.new  # a = []と同じ

  Array.newに引数を渡すと、その個数分の要素が追加される。このときの初期値はnil
a = Array.new(5)  # 要素が5つの配列を作成する
a  #=> [nil, nil, nil, nil, nil]

  さらに第2引数を指定したら、nil以外の初期値を設定できる
a = Array.new(5, 0)  # 要素が5つで0が初期値とする配列を作成する
a  #=> [0, 0, 0, 0, 0]

  Array.newではブロックを使って初期値を設定することもできる。ブロックは作成する要素の数だけ呼ばれて、ブロック引数には要素の添え字が渡される。
  配列にはブロックの戻り値がそれぞれ初期値として設定される。
    ex) ブロックを使うコード例
a = Array.new(10) { |n| n % 3 + 1 }  # 要素数が10で、1, 2, 3, 1, 2, 3...と繰り返す配列を作る
a  #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]



                     💠 4.7.13 配列に初期値を設定する場合の注意点
  だが、第2引数を使って初期値を指定する場合は注意が必要
a = Array.new(5, 'default')  # 要素が5つで'default'を初期値とする配列を作成する
a  #=> ["default", "default", "default", "default", "default"]

str = a[0]  # 1番目の要素を取得する
str  #=> "default"

str.upcase!  # 1番目の要素を大文字に変換する(破壊的変更)
str  #=> "DEFAULT"

a  #=> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT"]  # 配列の要素全てが大文字に変わってしまった

  これは配列の前要素が同じ文字列オブジェクトを参照してるから発生する問題。一見、配列の各要素は別々のように見えても、実際は1つのオブジェクトに紐づいてしまってるから、そのオブジェクトが変更されると無関係に見える他の要素も一緒に変更されてしまう
  この問題を避けるためには引数ではなく、ブロックで初期値を渡すようにする
a = Array.new(5) { 'default' }  # ブロックを使って、ブロックの戻り値を初期値とする(ブロック引数には添え字が渡されるが、ここでは使わないからブロック引数を省略)
a  #=> ["default", "default", "default", "default", "default"]

str = a[0]  # 1番目の要素を取得する
str  #=> "default"

str.upcase!  # 1番目の要素を大文字に変換する(破壊的変更)
str  #=> "DEFAULT"

a  #=> ["DEFAULT", "default", "default", "default", "default"]  # 1番目の要素だけが大文字になって、ほかは変わらない

  ブロックを使うと、ブロックが呼ばれるたびに文字列の"default"が新しく作成されるから、結果として配列の各要素は別々の文字列を参照することになる。
  ややこしいが、「同じ値で同一のオブジェクト」なのか、「同じ値で異なるオブジェクト」なのか、意識してコードを書かないと、思わぬ不具合を作ってしまう可能性がある。



                      💠 4.7.14 ミュータブル？　イミュータブル？
  P.124確認
  
    Column []や<<を使った文字列の操作
  文字列は配列とは無関係なオブジェクトだが、[]や<<を使って配列と同じような操作をすることができる
a = 'abcde'
a[2]  #=> "c"  # 3文字目を取得
a[1, 3]  #=> "bcd"  # 2文字目から3文字分を取得
a[-1]  #=> "e"  # 最後の1文字を取得

a[0] = 'X'  # 1文字目を"X"に置き換える
a  #=> "Xbcde"
a[1, 3] = 'Y'  # 2文字目から3文字分を"Y"に置き換える
a  #=> "XYe"
a << 'PQR'  # 末尾に"PQR"を連結する
a  #=> "XYePQR"