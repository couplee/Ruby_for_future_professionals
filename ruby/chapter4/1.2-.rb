                      💠 4.1.1 この章の例題：RGBカラー変換プログラム
  今回はRubyでRGBカラーを変換するプログラムを作る。RGBカラー変換プログラムの使用は下記の通り。
    ・10進数を16進数に変換するto_hexメソッドと、16進数を10進数に変換するto_intsメソッドの二つを定義する。
    ・to_hexメソッドは3つの整数を受け取って、それぞれを16進数に変換した文字列を返す。文字列の先頭には"#"をつける。
    ・to_intsメソッドはRGBカラーを表す16進数文字列を受け取って、R、G、Bのそれぞれを10進数の整数に変換した値を配列として返す。
    
    
    
                        💠 4.1.2 RGBカラー変換プログラムの実行例
to_hex(0, 0, 0)  #=> '#000000'
to_hex(255, 255, 255)  #=> '#ffffff'
to_hex(4, 60, 120)  #=> '#043c78'
  
to_ints('#000000')  #=> [0, 0, 0]
to_ints('#ffffff')  #=> [255, 255, 255]
to_ints('#043c78')  #=> [4, 60, 120]



                        💠 4.2 配列
  配列とは複数のデータをまとめて格納できるオブジェクトのこと。配列は下記のように[]と,を使って作成する(配列リテラル)
[]  # 空の配列を作る
[要素1, 要素2, 要素3]  # 3つの要素が格納された配列を作る


  配列はArrayクラスのオブジェクトになってる
[].class  #=> Array  # 空の配列を作成して、そのクラス名を確認する


  下記は数値の1,2,3が格納された配列を変数aに代入するコード例
a = [1, 2, 3]

  上記のコード例を下記のように改行して書くこともできる
a = [
      1,
      2,
      3  # 最後の要素に,をつけても文法上エラーにならない
]


  配列は数値に限らず、どんなオブジェクトも格納できる。下記は配列の中に文字列を格納する例
a = ['apple', 'orange', 'melon']

  異なるデータ型を格納することもできる。下記は数値と文字列を混ぜた配列を作成する例
a = [1, 'apple', 2, 'orange', 3, 'melon']

  配列の中に配列を含めることもできる
a = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]


  配列の各要素を取得する場合、[]と添字(数字)を使う。最初の要素の添字は0
a = [1, 2, 3]
a[0]  #=> 1  # 1つ目の要素を取得する
a[1]  #=> 2  # 2つ目の要素を取得する
a[2]  #=> 3  # 3つ目の要素を取得する

  存在しない要素を指定してもエラーではなく、nilが返ってくる
a = [1, 2, 3]
a[100]  #=> nil

  sizeメソッド(エイリアスメソッドはlength)を使うと配列の長さ(要素の個数)を取得できる
a = [1, 2, 3]
a.size  #=> 3
a.length  #=> 3



                      💠 4.2.1 要素の変更、追加、削除
  変更：下記の構文ように添字を指定して値を代入すると、指定した要素を変更することができる
配列[添字] = 新しい値

  下記のコードは2番目の要素を20に変更するコード例
a = [1, 2, 3]
a[1] = 20
a  #=> [1, 20, 3]

  元の配列の大きさよりも大きい添字を指定したら、間の値がnilで埋められる(今回は元の配列の大きさが3に対して、5番目の要素を設定した場合の実行結果は、4番目の要素がnilになる点に注目)
a = [1, 2, 3]
a[4] = 50
a  #=> [1, 2, 3, nil, 50]

  追加：<<を使って配列の最後に要素を追加することができる
a = []
a << 1
a << 2
a << 3
a  #=> [1, 2, 3]

  削除：配列内の特定の位置にある要素を削除したい場合、delete_atメソッドを使う
a = [1, 2, 3]

a.delete_at(1)  #=> 2  # 2番目の要素を削除する(削除した値が戻り値になる)
a  #=> [1, 3]

a.delete_at(100)  #=> nil  # 存在しない添え字を指定するとnilが返ってくる
a  #=> [1, 3]



                  💠 4.2.2 配列を使った多重代入
  第2章では変数を多重代入する方法を習った
a, b = 1, 2
a  #=> 1
b  #=> 2

  右辺に配列を置いた場合も同じように多重代入することができる
a, b = [1, 2]
a  #=> 1
b  #=> 2

  右辺に数が少ない場合はnilが返ってくる
c, d = [10]
c  #=> 10
d  #=> nil

  右辺の数が多い場合ははみ出した値が切り捨てられる
e, f = [100, 200, 300]
e  #=> 100
f  #=> 200


  配列の多重代入は便利に使える。たとえば、Rubyのdivmodメソッド(割り算の商と余りを配列として返すメソッド)などの場合、配列で受け取るよりも多重代入を使って最初から別々の変数に入れた方がすっきりとしたコードが書ける
14.divmod(3)  #=> [4, 2]  # divmodメソッドは商と余りを配列で返す

quo_rem = 14.divmod(3)  #=> [4, 2]  # 戻り値を値のまま受け取る
"商=#{quo_rem[0]}, 余り=#{quo_rem[1]}"  #=> "商=4, 余り=2"
  上記のコードを多重代入で別々の変数として受け取る
quotient, remainder = 14.divmod(3)  #=> [4, 2]
"商=#{quotient}, 余り=#{remainder}"  #=> "商=4, 余り=2"



                💠 4.3 ブロック

                💠 4.3.1 参考：Javaの繰り返し処理
                
                💠 4.3.2 Rubyの繰り返し処理
  RubyにもJavaのようにfor文はあるが、ほとんど使われない。Rubyの場合、forのような構文で繰り返し処理をさせるのではなく、
  配列自身に対して「繰り返せ」という命令を送る。ここで登場するのがeachメソッド。
    ex) 
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end
sum  #=> 10
  考え方は4.3.1で紹介したJavaの拡張forループに近いが、numbers.eachになってる点に注目する。
  これはRubyが言語機能として繰り返し処理を実行してるわけでなく、配列のeachメソッドが繰り返し処理を実行してる。
  eachメソッドの役割は配列の要素を最初から最後まで順番に取り出すことだが、取り出した要素をどう扱うかは、その時の要件で変わる。
  そこで登場するのがブロック。配列の要素を順番に取り出す作業はeachメソッドで行って、その要素をどう扱うかはブロックに記述する。上のコードでいうとdoからendまでがブロックになる。
  |n|のnはブロック引数と呼ばれ、eachメソッドから渡された配列の要素が入る。具体的にいうと、nには1,2,3,4が順番に渡される。ブロックの内部では自由にRubyのコードが書ける。
  上のコードではsum += nのように、変数sumに配列の各要素nを加算するコードを書いた。結果として、上のコードではforループと同じように、配列の中身を順に加算していくコードを書いたことになる。



                💠 4.3.3 配列の要素を削除する条件を自由に指定する
  ブロックは非常によく使われるから、each以外の使用例も見ていこう。たとえば、配列には指定した値に一致する要素を削除する、deleteというメソッドがある
a = [1, 2, 3, 1, 2, 3]
a.delete(2)  # 配列から値が2の要素を削除する
a  #=> [1, 3, 1, 3]

  だが、deleteメソッドを使うと引数で渡した値に完全一致する値しか削除できないから、deleteメソッドでは「奇数だけを削除する」などの処理を実行できない。
  こういう場合、deleteメソッドの代わりにdelete_ifメソッドを使う。先にdelete_ifメソッドを使って、奇数だけを削除するコードを見てみよう
a = [1, 2, 3, 1, 2, 3]
a.delete_if do |n|  # 配列から値が奇数の要素を削除する
  n.odd?
end
a  #=> [2, 2]

  delete_ifメソッドもeachメソッドと同じように、配列の要素を順番に取り出し、その要素をブロックに渡す。つまり、eachの場合と同じく、上のコードでもブロック引数nに1,2,3,1,2,3が順に渡されるが、
  そこからあとの処理はeachメソッドと違って、delete_ifメソッドはブロックの戻り値をチェックする。その戻り値が真であれば、ブロックに渡した要素を配列から削除する。偽であれば配列に残したままにする。
  ブロックの戻り値はメソッドと同様、最後に評価されて式になる。上のコードではn.odd?の結果がブロックの戻り値。odd?メソッドは数値が奇数の場合はtrueを返すから、上のコードを実行すると、配列から奇数の要素が削除される。
  delete_ifメソッドは「配列の要素を順番に取り出すこと」と「ブロックの戻り値が真であれば要素を削除すること」という共通処理を提供するが、どの要素を削除したのかは要件にあった処理を記述して、
  delete_ifメソッドの仕様に合わせて真または偽の値を返すようにする。
  このように、Rubyでは「要件を問わず共通する処理」はメソッド自身に、「要件によって異なる処理」はブロックにそろぞれ分担させて、一つの処理を完了させるメソッドが数多く用意されている。



              💠 4.3.4 ブロック引数とブロック内の変数
  もう一度、最初に紹介した配列の要素を加算する処理を見てみる
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end

  ブロック引数のnは別にnでなくてもかまわない。引数の名前はプログラマが自由に決めることができる
numbers.each do |i|
  sum += i
end

numbers.each do |number|
  sum += number
end

numbers.each do |element|
  sum += element
end

  ブロック引数を使わない場合、ブロック引数自体を省略できる
numbers.each do
  sum += 1
end

  ここまでブロックの内部には1行だけしかコードを記述しなかったが、ブロック内にはRubyのコードを自由に書くことができる。
  たとえば、下のコードは偶数のみ、値を10倍にしてから加算するコードの例。(条件分岐には第2章で習った条件演算子を使ってる)
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum_value = n.even? ? n * 10 : n
  sum += sum_value
end
sum  #=> 64

  sum_valueはブロック内で初めて登場した変数。このような変数のスコープ(有効範囲)はブロックの内部のみになる。もし、ブロックの外でsum_valueを参照するとエラーが発生する
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum_value = n.even? ? n * 10 : n
  sum += sum_value
end
sum_value  #=> NameError  # ブロックの外に出ると、sum_valueは参照できない

  一方、上のコードの変数sumのように、ブロックの外部で作成されたローカル変数はブロックの内部でも参照できる
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum_value = n.even? ? n * 10 : n
  sum += sum_value  # sumはブロックの外で作成されたから、ブロックの内部でも参照可能
end

  ブロック引数の名前をブロックの外にある変数の名前と同じにすると、ブロック内ではブロック引数の値が優先して参照される。(名前の重複によって、他の変数やメソッドが参照できなくなることをシャドーイングという)
numbers = [1, 2, 3, 4]
sum = 0
sum_value = 100
numbers.each do |sum_value|
  sum += sum_value
end
sum #=> 10

  しかし、このようなコードは読み手を混乱させやすく、思わぬ不具合の原因になったりするから、意図的に同じ名前を使うことは避けるようにする



                💠 4.3.5 do ... end と{}
  ここまでブロックは必ず改行を入れて書いたが、Rubyの文法上、改行を入れなくてもブロックは動作する
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n| sum += n end
sum #=> 10

  これだと読みにくいが、Rubyにはもうひとつブロックの記法がある。do ... endを使う代わりに、{}で囲んでもブロックを作れる
numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n| sum += n }  # do ... end の代わりに{}を使う
sum  #=> 10

  do ... endと{}はどっちも同じブロックだから、{}を使って、ブロック内部を改行させることも可能
numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n|
  sum += n
}
sum  #=> 10

  do ... endと{}の使い分けは明確に決まってるわけではないが、
  ・改行を含む長いブロックを書く場合はdo ... end
  ・1行でコンパクトに書きたいときは{}
  と使い分けられるケースが多い。ブロックの利用例はほかにもまだまだたくさんある。
  Rubyのコードを読む場合はメソッドの後ろに出てくるdo ... endや{}に注目して、ブロックがどんな用途で使われてるのか、調べるといい勉強になる。
  


                  💠 4.4 ブロックを使う配列のメソッド
  ここではブロックを使う配列のメソッドのうち、使用頻度が高い次のメソッドを紹介していく
  ・map/collect
  ・select/find_all/reject
  ・find/detect
  ・inject/reduce



                      💠 4.4.1 map/collect
  配列でrachメソッドの次に使用頻度が高いメソッドというばmapメソッド。（エイリアスメソッドはcollect）
  mapメソッドは各要素に対してブロックを評価した結果を新しい配列にして返す。たとえば、下記のように配列の各要素を10倍にした新しい配列を作るコードがあったとする
numbers = [1, 2, 3, 4, 5]
new_numbers = []
numbers.each { |n| new_numbers << n * 10 }
new_numbers  #=> [10, 20, 30, 40, 50]

  mapメソッドを使うとブロックの戻り値が配列の要素となる新しい配列が作成されるから、mapメソッドの戻り値をそのまま新しい変数に入れることができる
numbers = [1, 2, 3, 4, 5]
new_numbers = numbers.map { |n| n * 10}  # ブロックの戻り値が新しい配列の各要素になる
new_numbers  #=> [10, 20, 30, 40, 50]

  空の配列を用意して、ほかの配列をループ処理した結果を空の配列に詰め込んでいくような処理の大半は、mapメソッドに置き換えることができるはず



                💠 4.4.2 select/find_all/reject
  selectメソッド（エイリアスメソッドはfind_all）は各要素に対してブロックを評価して、その戻り値が真の要素を集めた配列を返すメソッド。
  例えば下記のように、偶数の数値だけを集めた配列を新たに作ることができる
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = numbers.select { |n| n.even? }  # ブロックの戻り値が真になった要素だけが集められる
even_numbers  #=> [2, 4, 6]

  rejectメソッドはselectメソッドの反対で、ブロックの戻り値が真になった要素を除外した配列を返す。言い換えると、ブロックの戻り値が偽である要素を集めるメソッド
numbers = [1, 2, 3, 4, 5, 6]
non_multiples_of_three = numbers.reject { |n| n % 3 == 0 }  # 3の倍数を除外する（3の倍数以外を集める）
non_multiples_of_three  #=> [1, 2, 4, 5]



                💠 4.4.3 find/detect
  findメソッド(エイリアスメソッドはdetect)はブロックの戻り値が真になった最初の要素を返す
numbers = [1, 2, 3, 4, 5, 6]
even_number = numbers.find { |n| n.even? }  # ブロックの戻り値が最初に真になった要素を返す
even_number  #=> 2



                    💠 4.4.4 inject/reduce
  injectメソッド(エイリアスメソッドはreduce)はたたみ込み演算を行うメソッド。このメソッドの動きは実際にサンプルコードを見た方がわかりやすい。
  たとえば、次のコードはeachメソッドを使って1から4までの値を変数sumに加算していくコード
numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n| sum += n }
sum #=> 10

  上のコードはinjectメソッドを使うと下記のように書くことができる
numbers = [1, 2, 3, 4]
sum = numbers.inject(0) { |result, n| result + n }
sum #=> 10

  上のコードでinjectメソッドの動きを説明すると、ブロックの第1引数(上のコードのresult)は初回のみinjectメソッドの引数(上のコードでは0)が入る。
  2回目以降は前回のブロックの戻り値が入る。ブロックの第2引数(上のコードのn)は配列の各要素(1,2,3,4)が順番に入る。ブロックの戻り値は次の回に引き継がれて、ブロックの第1引数(result)に入る。
  繰り返し処理が最後まで終わったら、ブロックの戻り値がinjectメソッドの戻り値になる。結果としてinjectメソッドとブロックは下記のように協調する
numbers = [1, 2, 3, 4]
sum = numbers.inject(0) { |result, n| result + n }

  ・1回目：result=0、n=1で、0+1=1。これが次のresultに入る
  ・2回目：result=1、n=2で、1+2=3。この結果が次のresultに入る
  ・3回目：result=3、n=3で、3+3=6。この結果が次のresultに入る
  ・4回目：result=6、n=4で、6+4=10。最後の要素に達したからこれがinjectメソッドの戻り値になる
  
  別の見方をすると、下記のような計算を行ったことになる
((((0 + 1) + 2) + 3) +4)

  ちょっとややこしいが、じっくりとコードと説明を読んで動きを理解する
  injectメソッドは数値以外のオブジェクトに対して適用することも可能。下記は文字列に対してinjectメソッドを適用する例
['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].inject('Sun') { |result, s| result + s }  #=>"SunMonTueWedThuFriSat"

  数値の場合と同様、上のコードでは下記のような処理を行ったことになる
(((((('Sun' + 'Mon') + 'Tue') + 'Wed') + 'Thu') + 'Fri') + 'Sat')



            💠 4.4.5 &とシンボルを使ってもっと簡潔に書く
  これは少し上級テクニックになるが、ブロックを使うメソッドは条件によってはかなり簡潔に書くことができる。
    ex)
['ruby', 'java', 'perl'].map { |s| s.upcase }  #=> ["RUBY, "JAVA, "PERL"]
  上記のコードを下記のように書き換えれる
['ruby', 'java', 'perl'].map(&:upcase)  #=> ["RUBY", "JAVA", "PERL"]

    ex)
[1, 2, 3, 4, 5, 6].select { |n| n.odd? }  #=> [1, 3, 5]
  上記のコードを下記のように書き換えれる
[1, 2, 3, 4, 5, 6].select(&:odd?)  #=> [1, 3, 5]

  mapメソッドやselectメソッドにブロックを渡す代わりに、&:メソッド名という引数を渡してる
  この書き方は次の条件がそろったときに使うことができる
  ①ブロック引数が1個だけある
  ②ブロックの中で呼び出すメソッドは引数がない
  ③ブロックの中では、ブロック引数に対してメソッドを1回呼び出す以外の処理がない
['ruby', 'java', 'perl'].map ③{ |①s| s.upcase② } 

　逆に、下記のようなコードでは&:メソッド名の書き方に変換することはできない
[1, 2, 3, 4, 5, 6].select { |n| n % 3 == 0 }  # ブロックの中でメソッドでなはく演算子を使ってる

[9, 10, 11, 12].mao { |n| n.to_s(16) }  # ブロック内のメソッドで引数を渡してる

[1, 2, 3, 4].map do |n|  # ブロックの中で複数の文を実行してる
  m = n * 4
  m.to_s
end

  &:upcaseや&:odd?がなんなのかは「10.5.2 &とto_procメソッド」で詳しく説明する。