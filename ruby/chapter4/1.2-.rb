                      💠 4.1.1 この章の例題：RGBカラー変換プログラム
  今回はRubyでRGBカラーを変換するプログラムを作る。RGBカラー変換プログラムの使用は下記の通り。
    ・10進数を16進数に変換するto_hexメソッドと、16進数を10進数に変換するto_intsメソッドの二つを定義する。
    ・to_hexメソッドは3つの整数を受け取って、それぞれを16進数に変換した文字列を返す。文字列の先頭には"#"をつける。
    ・to_intsメソッドはRGBカラーを表す16進数文字列を受け取って、R、G、Bのそれぞれを10進数の整数に変換した値を配列として返す。
    
    
    
                        💠 4.1.2 RGBカラー変換プログラムの実行例
to_hex(0, 0, 0)  #=> '#000000'
to_hex(255, 255, 255)  #=> '#ffffff'
to_hex(4, 60, 120)  #=> '#043c78'
  
to_ints('#000000')  #=> [0, 0, 0]
to_ints('#ffffff')  #=> [255, 255, 255]
to_ints('#043c78')  #=> [4, 60, 120]



                        💠 4.2 配列
  配列とは複数のデータをまとめて格納できるオブジェクトのこと。配列は下記のように[]と,を使って作成する(配列リテラル)
[]  # 空の配列を作る
[要素1, 要素2, 要素3]  # 3つの要素が格納された配列を作る


  配列はArrayクラスのオブジェクトになってる
[].class  #=> Array  # 空の配列を作成して、そのクラス名を確認する


  下記は数値の1,2,3が格納された配列を変数aに代入するコード例
a = [1, 2, 3]

  上記のコード例を下記のように改行して書くこともできる
a = [
      1,
      2,
      3  # 最後の要素に,をつけても文法上エラーにならない
]


  配列は数値に限らず、どんなオブジェクトも格納できる。下記は配列の中に文字列を格納する例
a = ['apple', 'orange', 'melon']

  異なるデータ型を格納することもできる。下記は数値と文字列を混ぜた配列を作成する例
a = [1, 'apple', 2, 'orange', 3, 'melon']

  配列の中に配列を含めることもできる
a = [[10, 20, 30], [40, 50, 60], [70, 80, 90]]


  配列の各要素を取得する場合、[]と添字(数字)を使う。最初の要素の添字は0
a = [1, 2, 3]
a[0]  #=> 1  # 1つ目の要素を取得する
a[1]  #=> 2  # 2つ目の要素を取得する
a[2]  #=> 3  # 3つ目の要素を取得する

  存在しない要素を指定してもエラーではなく、nilが返ってくる
a = [1, 2, 3]
a[100]  #=> nil

  sizeメソッド(エイリアスメソッドはlength)を使うと配列の長さ(要素の個数)を取得できる
a = [1, 2, 3]
a.size  #=> 3
a.length  #=> 3



                      💠 4.2.1 要素の変更、追加、削除
  変更：下記の構文ように添字を指定して値を代入すると、指定した要素を変更することができる
配列[添字] = 新しい値

  下記のコードは2番目の要素を20に変更するコード例
a = [1, 2, 3]
a[1] = 20
a  #=> [1, 20, 3]

  元の配列の大きさよりも大きい添字を指定したら、間の値がnilで埋められる(今回は元の配列の大きさが3に対して、5番目の要素を設定した場合の実行結果は、4番目の要素がnilになる点に注目)
a = [1, 2, 3]
a[4] = 50
a  #=> [1, 2, 3, nil, 50]

  追加：<<を使って配列の最後に要素を追加することができる
a = []
a << 1
a << 2
a << 3
a  #=> [1, 2, 3]

  削除：配列内の特定の位置にある要素を削除したい場合、delete_atメソッドを使う
a = [1, 2, 3]

a.delete_at(1)  #=> 2  # 2番目の要素を削除する(削除した値が戻り値になる)
a  #=> [1, 3]

a.delete_at(100)  #=> nil  # 存在しない添え字を指定するとnilが返ってくる
a  #=> [1, 3]



                  💠 4.2.2 配列を使った多重代入
  第2章では変数を多重代入する方法を習った
a, b = 1, 2
a  #=> 1
b  #=> 2

  右辺に配列を置いた場合も同じように多重代入することができる
a, b = [1, 2]
a  #=> 1
b  #=> 2

  右辺に数が少ない場合はnilが返ってくる
c, d = [10]
c  #=> 10
d  #=> nil

  右辺の数が多い場合ははみ出した値が切り捨てられる
e, f = [100, 200, 300]
e  #=> 100
f  #=> 200


  配列の多重代入は便利に使える。たとえば、Rubyのdivmodメソッド(割り算の商と余りを配列として返すメソッド)などの場合、配列で受け取るよりも多重代入を使って最初から別々の変数に入れた方がすっきりとしたコードが書ける
14.divmod(3)  #=> [4, 2]  # divmodメソッドは商と余りを配列で返す

quo_rem = 14.divmod(3)  #=> [4, 2]  # 戻り値を値のまま受け取る
"商=#{quo_rem[0]}, 余り=#{quo_rem[1]}"  #=> "商=4, 余り=2"
  上記のコードを多重代入で別々の変数として受け取る
quotient, remainder = 14.divmod(3)  #=> [4, 2]
"商=#{quotient}, 余り=#{remainder}"  #=> "商=4, 余り=2"



                💠 4.3 ブロック

                💠 4.3.1 参考：Javaの繰り返し処理
                
                💠 4.3.2 Rubyの繰り返し処理
  RubyにもJavaのようにfor文はあるが、ほとんど使われない。Rubyの場合、forのような構文で繰り返し処理をさせるのではなく、
  配列自身に対して「繰り返せ」という命令を送る。ここで登場するのがeachメソッド。
    ex) 
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end
sum  #=> 10
  考え方は4.3.1で紹介したJavaの拡張forループに近いが、numbers.eachになってる点に注目する。
  これはRubyが言語機能として繰り返し処理を実行してるわけでなく、配列のeachメソッドが繰り返し処理を実行してる。
  eachメソッドの役割は配列の要素を最初から最後まで順番に取り出すことだが、取り出した要素をどう扱うかは、その時の要件で変わる。
  そこで登場するのがブロック。配列の要素を順番に取り出す作業はeachメソッドで行って、その要素をどう扱うかはブロックに記述する。上のコードでいうとdoからendまでがブロックになる。
  |n|のnはブロック引数と呼ばれ、eachメソッドから渡された配列の要素が入る。具体的にいうと、nには1,2,3,4が順番に渡される。ブロックの内部では自由にRubyのコードが書ける。
  上のコードではsum += nのように、変数sumに配列の各要素nを加算するコードを書いた。結果として、上のコードではforループと同じように、配列の中身を順に加算していくコードを書いたことになる。



                💠 4.3.3 配列の要素を削除する条件を自由に指定する
  ブロックは非常によく使われるから、each以外の使用例も見ていこう。たとえば、配列には指定した値に一致する要素を削除する、deleteというメソッドがある
a = [1, 2, 3, 1, 2, 3]
a.delete(2)  # 配列から値が2の要素を削除する
a  #=> [1, 3, 1, 3]

  だが、deleteメソッドを使うと引数で渡した値に完全一致する値しか削除できないから、deleteメソッドでは「奇数だけを削除する」などの処理を実行できない。
  こういう場合、deleteメソッドの代わりにdelete_ifメソッドを使う。先にdelete_ifメソッドを使って、奇数だけを削除するコードを見てみよう
a = [1, 2, 3, 1, 2, 3]
a.delete_if do |n|  # 配列から値が奇数の要素を削除する
  n.odd?
end
a  #=> [2, 2]

  delete_ifメソッドもeachメソッドと同じように、配列の要素を順番に取り出し、その要素をブロックに渡す。つまり、eachの場合と同じく、上のコードでもブロック引数nに1,2,3,1,2,3が順に渡されるが、
  そこからあとの処理はeachメソッドと違って、delete_ifメソッドはブロックの戻り値をチェックする。その戻り値が真であれば、ブロックに渡した要素を配列から削除する。偽であれば配列に残したままにする。
  ブロックの戻り値はメソッドと同様、最後に評価されて式になる。上のコードではn.odd?の結果がブロックの戻り値。odd?メソッドは数値が奇数の場合はtrueを返すから、上のコードを実行すると、配列から奇数の要素が削除される。
  delete_ifメソッドは「配列の要素を順番に取り出すこと」と「ブロックの戻り値が真であれば要素を削除すること」という共通処理を提供するが、どの要素を削除したのかは要件にあった処理を記述して、
  delete_ifメソッドの仕様に合わせて真または偽の値を返すようにする。
  このように、Rubyでは「要件を問わず共通する処理」はメソッド自身に、「要件によって異なる処理」はブロックにそろぞれ分担させて、一つの処理を完了させるメソッドが数多く用意されている。



              💠 4.3.4 ブロック引数とブロック内の変数
  もう一度、最初に紹介した配列の要素を加算する処理を見てみる
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum += n
end

  ブロック引数のnは別にnでなくてもかまわない。引数の名前はプログラマが自由に決めることができる
numbers.each do |i|
  sum += i
end

numbers.each do |number|
  sum += number
end

numbers.each do |element|
  sum += element
end

  ブロック引数を使わない場合、ブロック引数自体を省略できる
numbers.each do
  sum += 1
end

  ここまでブロックの内部には1行だけしかコードを記述しなかったが、ブロック内にはRubyのコードを自由に書くことができる。
  たとえば、下のコードは偶数のみ、値を10倍にしてから加算するコードの例。(条件分岐には第2章で習った条件演算子を使ってる)
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|
  sum_value = n.even? ? n * 10 : n
  sum += sum_value
end
sum  #=> 64